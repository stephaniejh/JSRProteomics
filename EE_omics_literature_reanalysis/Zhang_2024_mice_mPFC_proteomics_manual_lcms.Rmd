---
title: "Zhang_2024_mice_mPFC_proteomics_manual_lcms"
author: "Stephanie Huang"
date: "2025-12-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Library

```{r}
library(UniProt.ws) # 1st test -  uniprot api 
library(tidyverse)
library(readxl)
library(gt)
```

Load df

Note this is manual list from

```{r}

raw_df <- read_excel('input/Zhang_2024_manual_proteomics_list.xlsx',
           sheet = 'dec_v1_fig')

```

```{r}
colnames(raw_df)
str(raw_df)
```

Mapping

```{r}
ratUp <- UniProt.ws(taxId = 10116)
```

```{r}
#available keytypes
keytypes(ratUp)

#available columns
columns(ratUp)
```

```{r}
to_map <- raw_df$`Gene/Protein`
```

```{r}
# map the 36 gene name entries from Zhang 2024 df 
ids_1 <- mapUniProt(from = "Gene_Name",
                      to = "UniProtKB",
                      #columns = c(""),
                      query = list(taxId = 10116, ids = to_map)
                      ) #  returns 22325 x 8 - all species?! not just rat???

# took 5 min on jennifer - returned warning "IDs not mapped: UPF0665 protein C2orf69 homolog"
```

```{r}
# filter for rat & mouse only - from 22325 to 304
ids_2 <- ids_1 %>%
  filter(Organism %in% c('Rattus norvegicus (Rat)', 'Mus musculus (Mouse)')) 
```

```{r}
# ids_3 - get all cols from uniprot for the rat & mouse entries 
all_cols <- columns(ratUp)
ids_2_to_map <- ids_2$Entry

ids_3 <- select(x = ratUp,
                keys = ids_2_to_map, 
                columns = all_cols,
                keytype = "UniProtKB")  # takes 4 sec, returns 304 x 296 cols
```

```{r}
# cols I want from uniprot
my_up_cols <-  c('From', 'Entry', "Entry.Name", "Reviewed", "Protein.names",
                 "Gene.Names", "Gene.Names..primary.", "GeneID", "Organism", "Length",
                 "Protein.existence", "Protein.families", "Keywords", "Keyword.ID",
                 "Annotation", "Function..CC.", "Subcellular.location..CC.",
                 "Tissue.specificity", "Gene.Ontology..GO.", "Gene.Ontology.IDs",
                 "KEGG", "Comments", "Date.of.creation", "Date.of.last.modification",
                 "Date.of.last.sequence.modification")

# my_up_cols <-  c(From, Entry, Entry.Name, Reviewed,  Protein.names,
#                  Gene.Names, Gene.Names..primary., GeneID,  Organism,  Length,
#                  Protein.existence, Protein.families, Keywords, Keyword.ID,
#                  GO, KEGG)



# Also rename From column in ids_2 (containing the gene_names searched (from Zhang df))
colnames(ids_2)[1] <-'Gene_From_Zhang' 
```

```{r}
# ids_3 only reference proteome entries + cols of interest
ids_4 <- ids_3 %>%
  
    # get entries with reference proteome tagged 
  filter(str_detect(Keywords, "Reference")) %>%  # from 304 to 212
  
    # select desired columns (see above)
  dplyr::select(all_of(my_up_cols)) %>% # need all_of if ref other list
  
    # then bind to gene names queried from Zhang df. 
  left_join(ids_2[ , 1:2], #1st 2 cols from ids_2
            by = join_by(From == Entry)) %>%  # ids_4 From matches ids_2 Entry 
  
  mutate(Annotation = as.numeric(Annotation)) # not needed? but just to be safe?
```

```{r}
# NOTE - "IDs not mapped: UPF0665 protein C2orf69 homolog"
# unique genes from ids_4 | 36
unique(ids_4$Gene.Names..primary.)
length(unique(ids_4$Gene.Names..primary.))

# unique genes from Zhang raw df | 36
unique(raw_df$`Gene/Protein`)
length(unique(raw_df$`Gene/Protein`))

# differences between lists | 3 of 36
setdiff(ids_4$Gene.Names..primary., raw_df$`Gene/Protein`)
length(setdiff(ids_4$Gene.Names..primary., raw_df$`Gene/Protein`))

# commonalities between list | 33 of 36
intersect(ids_4$Gene.Names..primary., raw_df$`Gene/Protein`)
length(intersect(ids_4$Gene.Names..primary., raw_df$`Gene/Protein`))
```

------------------------------------------------------------------------

## for loops

-   <https://www.epirhandbook.com/en/new_pages/iteration.html>

-   <https://r4ds.hadley.nz/iteration.html>

### 3 Core components

1.  The **sequence** of items to iterate through

2.  The **operations** to conduct per item in the sequence

3.  The **container** for the results (optional)

The basic syntax is: `for (item in sequence) {do operations using item}`. Note the parentheses and the curly brackets. The results could be printed to console, or stored in a container R object.

```{r}
# a simple for loop
for (num in c(1,2,3,4,5)) { 
  print(num + 2)
}
```

### Sequence

This is the “for” part of a *for loop* - the operations will run “for” each item in the sequence. The sequence can be a series of values (e.g. names of jurisdictions, diseases, column names, list elements, etc), or it can be a series of consecutive numbers (e.g. 1,2,3,4,5). 

The basic structure of a sequence statement is `item in vector`.

-   

```{r}
# make vector of the gene names 
gene_names_vec <- unique(ids_4$Gene_From_Zhang)
gene_names_vec
```

```{r}
# chosen to use gn to represent values from the vector gene_names_vec
# 1st iteration of the loop will be hospital_names[[1]], 2nd will be hospital_names[[2]]

for (gn in gene_names_vec){ # sequence
  # OPERATIONS HERE
}
```

Example: sequence in column names

-   Double brackets used to subset [[]]

    -   see <https://www.epirhandbook.com/en/new_pages/basics.html#accessindex-with-brackets>

```{r}
# OR... 
# for each column in ids_4 print the sum of the column NA values
for (col in names(ids_4)){
  # op
  print(sum(is.na(ids_4[[col]])))
}


# RESULT
# e.g. col 8 GENEID is 118 so 118 missing values | KEGG is 151
# use this to check missing values in annotation dbi!!! very useful! :D
# The below code returns numbers, becomes the value of i in their respective loop.
# seq_along(ids_4)  # use on a named vector
```

Sequence of numbers (e.g. down rows)

-   “for every item in a sequence of numbers from 1 to the total number of rows in my data frame, do X”

```{r}
for (i in 1:nrow(ids_4)) {
  # OPERATION
}

#seq_along(ids_4)  # use on a named vector ? - see link for more info? 

```

### Operations

This is code within the curly brackets `{ }` of the *for loop*.

-   You want this code to run for each “item” in the *sequence*. Therefore, be careful that every part of your code that changes by the “item” is correctly coded such that it actually changes!

    -   E.g. remember to use `[[ ]]` for indexing.

```{r}
# make CONTAINER to store results - a character vector
my_container <- vector(mode = "character", length = nrow(ids_4))

# the for loop
for (i in 1:nrow(ids_4)){ # SEQUENCE - for each item from 1 up to the nrows
  
  # OPERATIONS
  # part 1 
  # extract values from linelist for row i, using brackets for indexing
  primary_gene_name <- ids_4$`Gene.Names..primary.`[[i]] # get 1° gene of that row
  zhang_entry <- ids_4$Gene_From_Zhang[[i]] # get Zhang df entry of that row
  protein_name <- ids_4$Protein.names[[i]] # protein name of that row
  rodent <- ids_4$Organism[[i]] # rat or mouse
  
  # part 2
  # combine the 4 and store in container vector at indexed location
  my_container[[i]] <- str_c(primary_gene_name, zhang_entry, protein_name, rodent,
                             sep = ",")
  
} # end for loop

# display 1st 10 rows of container
head(my_container, 10)
```

### Container

-   The output of a for loop can be stored in a container for later use.

    -   The container can be vector, a data frame or even a list.

    -   Create before starting the loop. Can use vector() for vectors or lists, or matrix() & data.frame() for a data frame.

#### Empty Vector

-   make empty vector with vector()

    -   Specify mode = based on expected class of objects to be inserted

        -   "double" - holds numbers

        -   "character" - holds strings

        -   "logical" - TRUE or FALSE

```{r}
# empty vector
gene_container <- vector(mode = "double", # we expect to store numbers
                         length = length(unique(ids_4$`Gene.Names..primary.`))
                         )
```

#### Empty data frame

make empty data frame by specifying number of rows & columns

```{r}
empty_df <- data.frame(matrix(ncol = 2, nrow = 3))
```

Empty List

-   A list is like a vector, but holds other R objects within it that can be different classes!

    -   Items in a list could be a single number, a df, a vector, & even another list!

    -   Initialize an empty list with vector() but set mode = "list", then specify length as desired.

```{r}
plots <- vector(mode = "list", length = 16)
```

### Printing

Note that to print from within a for loop you will likely need to explicitly wrap with the function print().

```{r}
# The results are not stored in a container, but rather are printed to console with the print() function.

# this prints the no. of obs/cases for that gene in the id_4 df 
for (i in gene_names_vec){
  gene_cases <- ids_4 %>% filter(Gene_From_Zhang == i)
  print(nrow(gene_cases))
}
```

### Testing your for loop

-   To test your loop, you can run a command to make a temporary assignment of the “item”, such as `i <- 10` or `i <- "Esyt1"`. Do this *outside the loop* & then run your operations code only (the code within the curly brackets) to see if the expected results are produced.

### Looping plots - go to Lichti et al., 2014 script for looping plots

```{r}

```

### **Tracking progress of a loop**

A loop with many iterations can run for many minutes or even hours. Thus, it can be helpful to print the progress to the R console. The `if` statement below can be placed *within* the loop operations to print every 100th number. Just adjust it so that `i` is the “item” in your loop.

```{r}
# loop with code to print progress every 100 iterations
for (i in seq_len(nrow(linelist))){

  # print progress
  if(i %% 100==0){    # The %% operator is the remainder
    print(i)

}}
```

-   <https://www.epirhandbook.com/en/new_pages/iteration.html>

-   <https://r4ds.hadley.nz/iteration.html>

-   <https://datacarpentry.github.io/semester-biology/materials/for-loops-R/>

------------------------------------------------------------------------

Continued...

-   <https://www.modernstatisticswithr.com/progchapter.html#nestedloops>

-   <https://adv-r.hadley.nz/control-flow.html>

Set up

```{r}
rats_for_map <- ids_4 %>%
  filter(str_detect(Organism, "Rat")) %>%
  group_by(Reviewed, Gene.Names..primary., Protein.names) %>%
  #filter(Annotation == max(Annotation, na.rm = TRUE)) # same as slice_max func below
  slice_max(Annotation, n = 1) %>% # takes top score (annotation 5)
  ungroup()
```

```{r}
# make vector of unique gene/protein names from the Zhang data frame
gp_names <- unique(rats_for_map$Gene_From_Zhang) 

# make a  container lists to store the resuts
mapped_rat_list <- vector("list") # empty seems fine since pasting from existing df?

colnames(raw_df)
colnames(ids_4)
```

Operations

```{r}
# Entirely Base R approach
for (gp in gp_names){ # sequence
  
  # OPERATIONS
  # set up grouping by gene
  current_rat_gp <- subset(rats_for_map, Gene_From_Zhang == gp)
  gp_row <- NULL # apparently for safety/clarity - to reset & initialize?
  
  # if - 1st condition - if swiss prot | if reviewed = true paste row + add comment
  if (any(current_rat_gp$Reviewed == "reviewed", na.rm = TRUE)) {
    gp_row <- subset(current_rat_gp, Reviewed == "reviewed")[1, ]
    gp_row$Criterion <- "is SwissProt"
   
    # else if - 2nd condition if reference proteome 
  } else if (any(grepl("Reference", current_rat_gp$Keywords))) {
    gp_row <- subset(current_rat_gp,
                     grepl("Reference", current_rat_gp$Keywords))[1,]
    gp_row$Criterion <- "is Reference Proteome"

    # else if - 3rd condition 
  } else if (any(current_rat_gp$Reviewed == "unreviewed", na.rm = TRUE)) {
    gp_row <- subset(current_rat_gp, Reviewed == "unreviewed")[1, ]
    gp_row$Criterion <- "is unreviewed"

  }
    
  else {
    gp_row$Criterion <- "nothing"
    next
  }
  
  mapped_rat_list[[gp]] <- gp_row
  #   if (!is.null(gp_row)) {
  #     mapped_rat_list[[gp]] <- gp_row
  # }

}
```

```{r}
mapped_rat_df <- bind_rows(mapped_rat_list)
```

com_rat_df

```{r}
# 32/36 mapped
com_rat_df <- left_join(raw_df, mapped_rat_df,
                        by = join_by(`Gene/Protein` == Gene_From_Zhang))
```

```{r}
#write_excel_csv(com_rat_df, "output/Zhang_output_test_1.csv")
```

------------------------------------------------------------------------

```{r}
# colnames(com_rat_df) # check col names 

# make lit review table 
lit_re <- com_rat_df %>%
  mutate(
    Space = " ",
    Year = 2024,
    Author = 'Zhang',
    Animal = 'Mice',
    Condition = ' ',
    Region = 'Medial_Prefrontal_Cortex',
    Whole = 'Yes',
    Exp_type = 'Protein',
    Method = 'PROTEOMICS_LCMS_LFQ_OS',
    Used_name = `Gene/Protein`,
    Mod = " ",
    Mod_type = " ",
    Gene_name = `Gene.Names..primary.`,
    Comparison = 2,
    In_EE = Direction,
    Fold_change = ' ',
    Arrows = ifelse(Direction == 'Up', '+', '-'),
    Significant = 'yes',
    pvalue = ' ',
    N_tested = ' ',
    Stats_adj = '?',
    Note = ' ',
    Full_name = `Protein.names`,
    Uniprot_rat_accession = Entry,
    Uniprot_entry_name = `Entry.Name`,
    Uniprot_link = ifelse(!is.na(Entry),
                          paste0('https://www.uniprot.org/uniprotkb/', Entry,'/entry'),
                          ' '),
    Wikipedia_link = ifelse(!is.na(Entry),
                            paste0('https://en.wikipedia.org/wiki/',
                                   `Gene.Names..primary.`),
                            ' '),
    Curation_method = ifelse(!is.na(Entry),
                             'auto - gene_name-to-uniprot (rat)',
                             'manual'),
    Class_group = ' ',
    Other_link = ' ',
    Other_comments = '~Uniprot Curation Criteria',
    misc = ifelse(!is.na(Criterion),
                  paste0(Criterion),
                  'rat unmapped')
  )
```

```{r}
#write out | na values = blank 
# write_excel_csv(lit_re,
#                 "output/2025_12_13_Zhang_2024_mPFC_lit_re_mapped_w_rat_ID_v1.csv",
#                 na = "")
```
